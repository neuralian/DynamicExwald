# test Neuralian Toolbox

# test calls:

# test_Wald_sample(.013, 1.0)

# test_Exponential_sample(.001)

# test_Exwald_sample_sum(.013, 0.1, .01)

# test_Exwald_sample_sim(.013, 0.1, .01)

# inhomogenousPoisson_test(200)

# inhomogenousWald_test(1000)

# test_Exwald_Neuron_spontaneous(500, (.013, 0.1, .01))

# test_Exwald_Neuron_sin(500, (.013, 0.1, .01), (.25, 1.0))

# test_Exwald_Neuron_phasedistribution(50000, (.013, 0.1, .01), (.25, 1.0), vec([45.0*i for i in 0:7]))    

# show_Exwald_Neuron_sineresponse((.013, 0.1, .01), (.25, 1.0), 64)
# show_Exwald_Neuron_sineresponse((.013, 0.1, .01), (.25, 1.0), 64, 0.05, 0.001)





include("Neuralian.jl")
include("NeuralianFit.jl")
#include("NeuralianPlot.jl")

using Infiltrator, Colors

# Compare first passage time simulation histogram to InverseGaussian from Distributions.jl 
function test_Wald_sample(mu::Float64, lambda::Float64)

    N = 5000  # sample size
    interval = zeros(N)
    Wald_sample(interval, mu, lambda)

    F = Figure()
    ax = Axis(F[1,1])
    hist!(interval, normalization=:pdf, bins=100)
       #  label=@sprintf "First passage times (%.3f, %.3f)" mu lambda)
    t = DEFAULT_SIMULATION_DT:DEFAULT_SIMULATION_DT:(maximum(interval)*1.2)
    lines!(t, pdf(InverseGaussian(mu, lambda), t), color = :red)
    display(F)

    #@infiltrate
    xlims!(0.0, xlims(ax)[2])
    text!(ax, 0.75*xlims(ax)[end], 0.75*ylims(ax)[end], text = "Wald ($mu, $lambda)")
    # xlims!(0.0, t[end])
    #display(F)
    (F,ax)
end

# Compare Expsim histogram to Exponential 
function test_Exponential_sample(tau::Float64, dt::Float64=DEFAULT_SIMULATION_DT)

    N = 5000  # sample size
    interval = zeros(N)
    (m, s, threshold) = Exponential_sample(interval, tau)

    F = Figure()
    ax = Axis(F[1,1])
    hist!(interval, normalization=:pdf, bins=200)

     #   label=@sprintf "Threshold trigger (%.2f, %.2f, %.2f)" m s threshold)
    t = 0.0:dt:(maximum(interval)*1.2)
    lines!(t, exp.(-t ./ tau) ./ tau, linewidth=2.5, color = :red)
     #   label=@sprintf "Exponential (τ = %.2f)" tau)  #pdf(InverseGaussian(mu, lambda), t))
    xlims!(0.0, t[end])
    display(F)
    text!(ax, 0.25*t[end], 0.85*ylims(ax)[end], color = :dodgerblue,
        text =@sprintf "Threshold trigger (μ = %.2f, σ = %.2f, Thr = %.2f; τ = %.2f)" m s threshold tau)
    text!(ax, 0.5*t[end], 0.75*ylims(ax)[end], color = :salmon1,
        text =@sprintf "Exponential (τ = %.2f)" tau)
   # @infiltrate
end


# Inhomogeneous Poisson by threshold-crossing with time-varying noise
# N = number of intervals
function inhomogenousPoisson_test(N, play_audio::Bool = false)

    tau = 0.1     # mean interval at mean stimulus level (s)

    f = 0.25    # stimulus frequency
    a = 0.25    # amplitude
    m0 = 10.0   # mean
    s = 1.0     # noise s.d.
    q(t) = m0 + a * sin(2 * pi * f * t)  # stimulus waveform

    # sampling interval for GLR
    dt = .001

    I = zeros(N) # space for intervals

    # trigger level with N(m0,1.0) input noise
    trigger = TriggerThreshold_from_PoissonTau(m0, s, tau)

    ThresholdTrigger_simulate(I, q, s, trigger)

    spt = cumsum(I)   # spike times from intervals

    #bs = s2b(spt, 1.0e-4)  # binary representation at 10KHz
    # soundsc(bs, 10000)     # play audio at 10KHz

    (T,r) = GLR(spt, [0.5], dt)
    
    #@infiltrate
    
    # reverse-engineer τ from q
    r0 = [1.0/PoissonTau_from_ThresholdTrigger(q(t), s, trigger, DEFAULT_SIMULATION_DT) for t in T]

    F = Figure(size = (1600, 400))
    ax = Axis(F[1,1])

        ax.title = "Poisson Simulation"
    
    splot!(ax,spt)
    lines!(T, r)
    lines!(T, [q(x) for x in T])
    lines!(T, r0, color = :salmon1)

    display(F)

    if play_audio
        bs = s2b(spt, 1.0e-4)  # binary representation at 10KHz
        soundsc(bs, 1.0e4) 
    end

end

# Inhomogeneous Inverse Gaussian by simulating time-to-barrier
#  with time-varying drift
# N = number of intervals
function inhomogenousWald_test(N, play_audio::Bool = false)

    I = zeros(N)
    # FPT process parameters for spontaneous Exwald
    mu = 0.013
    lambda = 0.1
    dt = DEFAULT_SIMULATION_DT
    (v0, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)   # Drift speed, noise s.d. & barrier height for Wald component

    #q(t) = t < 50.0 ? 9.5 : 10.0
    f = 1.0
    a = 80.0
    q2(t) = v0 + a * sin(2 * pi * f * t)
    FirstPassageTime_simulate(I, q2, s, barrier, dt)
    #@infiltrate

    spt = cumsum(I)   # spike times from intervals

    gdt = 1.0e-3
    (t,r) = GLR(spt, [0.1], gdt)


    F = Figure(size=(1600, 400))
    ax = Axis(F[1,1])

    ax.title = "Wald Simulation"

    splot!(ax,spt, 20.0)
    lines!(t, r)
    plot!(t, [q2(x) for x in t], strokecolor = :salmon1, markersize = 1.0, strokewidth = 1.0)



    display(F)

    if play_audio
        bs = s2b(spt, 1.0e-4)  # binary representation at 10KHz
        soundsc(bs, 1.0e4)     # play audio at 10KHz
    end

end



# test Exwald sample generated by adding samples from Exponential and Wald distributions
function test_Exwald_sample_sum(mu, lambda, tau)

    N = 5000  # sample size
    I = Exwald_sample_sum(N, mu, lambda, tau)

    (v, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)   # Drift speed, noise s.d. & barrier height for Wald component
    trigger = TriggerThreshold_from_PoissonTau(v, s, tau)            # threshold for Poisson component using same noise
    
    F = Figure()
    ax = Axis(F[1,1])
    ax.title = "Exwald Sample by sum of Exponential and Wald Samples"

    hist!(I, normalization=:pdf, bins=100)
    #    text!(ax, text = @sprintf "Simulation (%.5f, %.5f, %.5f, %.2f)" v s barrier trigger)

    dt = 1.0e-5
    T = maximum(I) * 1.2
    t = collect(dt:dt:T)
    lw = 2.5

    X = Exwaldpdf(mu, lambda, tau, t)
    W = pdf(InverseGaussian(mu, lambda), t)
    P = exp.(-t ./ tau) ./ tau

    lines!(t, W, linewidth = 2.0)

    lines!(t, P, linewidth = 2.0)
    #   text!(ax, text = @sprintf "Exponential (%.5f)" tau)
    lines!(t, X, linewidth = 2.0)
    #  text!( text = @sprintf "Exwald (%.5f, %.5f, %.5f)" mu lambda tau)

    ymax = max(maximum(X), maximum(W)) * 1.25
    ylims!(0.0, ymax )
    xlims!(0.0, T)

    text!(ax, T/2.0, 0.8*ymax, text = @sprintf "μ = %5f " mu)
    text!(ax, T/2.0, 0.75*ymax, text = @sprintf "λ =  %5f" lambda)
    text!(ax, T/2.0, 0.7*ymax, text = @sprintf "τ =  %5f" tau)
    #@infiltrate

    display(F)
end


# # test Exwald sample generated by simulating threshold trigger & drift-diffusion FPT
function test_Exwald_sample_sim(mu, lambda, tau)

    N = 5000  # sample size
    I =  Exwald_sample_sim(N, mu, lambda, tau)

    (v, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)   # Drift speed, noise s.d. & barrier height for Wald component
    trigger = TriggerThreshold_from_PoissonTau(v, s, tau)            # threshold for Poisson component using same noise
    
    F = Figure()
    ax = Axis(F[1,1])
    ax.title = "Exwald Sample by Threshold Trigger & Drift-Diffusion First Passage Time"

    hist!(I, normalization=:pdf, bins=100)
    #    text!(ax, text = @sprintf "Simulation (%.5f, %.5f, %.5f, %.2f)" v s barrier trigger)

    dt = 1.0e-5
    T = maximum(I) * 1.2
    t = collect(dt:dt:T)
    lw = 2.5

    X = Exwaldpdf(mu, lambda, tau, t)
    W = pdf(InverseGaussian(mu, lambda), t)
    P = exp.(-t ./ tau) ./ tau

    lines!(t, W, linewidth = 2.0)

    lines!(t, P, linewidth = 2.0)
    #   text!(ax, text = @sprintf "Exponential (%.5f)" tau)
    lines!(t, X, linewidth = 2.0)
    #  text!( text = @sprintf "Exwald (%.5f, %.5f, %.5f)" mu lambda tau)

    ymax = max(maximum(X), maximum(W)) * 1.25
    ylims!(0.0, ymax )
    xlims!(0.0, T)

    text!(ax, T/2.0, 0.8*ymax, text = @sprintf "μ = %5f " mu)
    text!(ax, T/2.0, 0.75*ymax, text = @sprintf "λ =  %5f" lambda)
    text!(ax, T/2.0, 0.7*ymax, text = @sprintf "τ =  %5f" tau)
    #@infiltrate

    display(F)
end




# function dynamicExwald_test(N, listen::Bool=false)

#     I = zeros(N)    # generate sample of size N 

#     # baseline (spontaneous) Exwald parameters
#     mu = 0.013
#     lambda = 0.1
#     tau = 0.01

#     dt = DEFAULT_SIMULATION_DT  # just to be clear

#     # First passage time model parameters for spontaneous Wald component 
#     (v0, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)

#     # trigger threshold for spontaneous (mean==tau) Exponwential samples  with N(v0,s) noise
#     trigger = TriggerThreshold_from_PoissonTau(v0, s, tau, dt)

#     # sinusoidaal stimulus (input noise mean) parameters
#     f = 1.0         # modulation frequency Hz (nb not spike frequency/firing rate)
#     a = 0.0        # modulation amplitude

#     # stimulus waveform
#     q(t) = v0 + a * sin(2 * pi * f * t)

#     # Exwald samples by simulating physical model of FPT + Poisson process in series
#     Exwald_simulate(I, q, s, barrier, trigger, dt)
#     #@infiltrate

#     # Exwald neuron spike times from Exwald intervals
#     spt = cumsum(I)   # spike times from intervals

#     # plot spike train
#     splot(spt, 20.0)

#     # Gaussian rate estimate
#     gdt = 1.0e-3                      # sample interval for GLR estimate
#     (t, r) = GLR(spt, [0.1], gdt)       # rate estimate r at sample times t

#     # plot rate estimate 
#     plot!((t, r), size=(1000, 400))
#     # plot stimulus
#     display(plot!(t, [q(x) for x in t]))

#     if listen
#         bs = s2b(spt, 1.0e-4)  # binary representation at 10KHz
#         soundsc(bs, 10000)     # play audio at 10KHz
#     end
# end



# test dynamic Exwald with no stimulus
function test_Exwald_Neuron_spontaneous(N::Int64,
    Exwald_param::Tuple{Float64,Float64,Float64}, dt::Float64=DEFAULT_SIMULATION_DT)

    (mu, lambda, tau) = Exwald_param
    spt = Exwald_Neuron_Nspikes(N, (mu, lambda, tau), t -> 0.0)


    F = Figure()
    ax = Axis(F[1,1])

    hist!(diff(spt), bins=64, normalization=:pdf)
    # label=@sprintf "Simulation")
    #xlims!(0.0, xlims(ax)[2])

    T = maximum(diff(spt))
    t = collect(0.0:dt:T)

    X = Exwaldpdf(mu, lambda, tau, t)
    W = pdf(InverseGaussian(mu, lambda), t)
    P = exp.(-t ./ tau) ./ tau

    lw = 2.5
    lines!(t, W, linewidth=lw)
    #    label=@sprintf "Wald (%.5f, %.5f)" mu lambda)
    lines!(t, P, linewidth=lw)
    # label=@sprintf "Exponential (%.5f)" tau)
    lines!(t, X, linewidth=lw * 1.5)
    # label=@sprintf "Exwald (%.5f, %.5f, %.5f)" mu lambda tau)

    ymax = max(maximum(X), maximum(W)) * 1.25
    ylims!(0.0, ymax)


    xlims!(0.0, T)
    # ylims!(0.0, 2.0 * maximum(X))
    ax.title = "Exwald Neuron Model Spontaneous ISI"

    text!(ax, T/2.0, 0.8*ymax, text = @sprintf "μ = %.5f" mu)
    text!(ax, T/2.0, 0.75*ymax, text = @sprintf "λ = %.5f" lambda)
    text!(ax, T/2.0, 0.7*ymax, text = @sprintf "τ = %.5f" tau)
    
    display(F)


end

# test dynamic Exwald with sinusoidal stimulus
# stimulus parameters Stim_param = (A, F), A = amplitude, F = frequency (Hz)
function test_Exwald_Neuron_sin(N::Int64,
    Exwald_param::Tuple{Float64,Float64,Float64}, Stim_param::Tuple{Float64,Float64}, dt::Float64=DEFAULT_SIMULATION_DT)

    # extract parameters
    (mu, lambda, tau) = Exwald_param
    (A, F) = Stim_param
    (v, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)   # Drift speed, noise s.d. & barrier height for Wald component
    trigger = TriggerThreshold_from_PoissonTau(v, s, tau, dt)            # threshold for Poisson component using same noise

    # sinusoidal stimulus
    stimulus(t) = A * sin(2 * π * F * t)

    # simulate Exwald neuron
    spt = Exwald_Neuron_Nspikes(N, (mu, lambda, tau), stimulus)

   # Gaussian rate estimate
   gdt = 1.0e-3                      # sample interval for GLR estimate
   (t, r) = GLR(spt, [0.05], gdt)       # rate estimate r at sample times t

    #@infiltrate

    # compute expected mean rate (1/mean interval) during stimulus
    timevarying_τ = [PoissonTau_from_ThresholdTrigger(v.+stimulus(tt), s, trigger, DEFAULT_SIMULATION_DT) for tt in t]
    timevarying_μ = [Wald_parameters_from_FirstpassageTimeModel(v.+stimulus(tt), s, barrier)[1] for tt in t]
    timevarying_rate = 1.0./(timevarying_μ+timevarying_τ)

    



    Fig = Figure(size=(1200, 400))
    ax = Axis(Fig[1,1])



    # plot spike train
    splot!(ax, spt, 20.)

 



    # plot rate estimate 
    lines!(t, r, linewidth=2.5)

    # expected rate
    lines!(t,timevarying_rate, linewidth = 2.5 )

    # plot spontaneous level
    #lines!([t[1], t[end]], v * [1.0, 1.0])
    # plot stimulus
    lines!(t, [stimulus(x) for x in t], color = :salmon1, linewidth = 2.5)

    display(Fig)

    return spt
end

# Plot ISI distribution for Exwald neuron at specified phases of sinusoidal stimulus
# overlay the model-predicted Exwald for each phase
#   0 <= phase <= 360
# N = number of spikes 
# Exwald_param = (mu, lambda, tau)
# Stim_param = (amplitude, frequency /Schwarz)
# Example call:
#  test_Exwald_Neuron_phasedistribution(500000, xwp, (.25, 1.0), vec([45.0*i for i in 0:7]))
function test_Exwald_Neuron_phasedistribution(N::Int64,
    Exwald_param::Tuple{Float64,Float64,Float64},
    Stim_param::Tuple{Float64,Float64},
    phaseAngle::Vector{Float64},
    dt::Float64=DEFAULT_SIMULATION_DT)

    # extract parameters
    (mu, lambda, tau) = Exwald_param
    (A, F) = Stim_param
    (v0, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)   # Drift speed, noise s.d. & barrier height for Wald component
    trigger = TriggerThreshold_from_PoissonTau(v0, s, tau, dt)            # threshold for Poisson component using same noise

    # sinusoidal stimulus
    stimulus(t) = A * sin(2 * π * F * t)

    # simulate Exwald neuron
    spt = Exwald_Neuron_Nspikes(N, (mu, lambda, tau), stimulus)

    # rate estimate
    dt4glr = 0.01
    (tx, glrate) = GLR(spt, [0.1], dt4glr);

    Npts = 128
    R0 = 1.0
    NP = length(phaseAngle)
    FigRadius = 500.0

    Fig = Figure(size = (2.0*FigRadius, 2.0*FigRadius))

    # ax0 allows text to be placed anywhere on the figure
    ax0 = Axis(Fig[1,NP+1])
    xlims!(ax0, 0., 1.)
    ylims!(ax0, 0., 1.)
    text!(ax0, .14, .95, fontsize = 24,
    text = "Exwald neuron ISI distribution during sinusoidal angular acceleration")
    text!(ax0, .5, .73, fontsize = 12, align = (:center, :center), text = "Peak acceleration")
    text!(ax0, .05, .92, fontsize = 16, text = "Spontaneous Model Parameters:")
    h0 = .9
    dh = .02
    text!(ax0, .125, h0, fontsize = 16, text = @sprintf "μ = %0.4f" mu)
    text!(ax0, .125, h0-dh, fontsize = 16, text = @sprintf "λ = %0.4f" lambda)    
    text!(ax0, .125, h0-2*dh, fontsize = 16, text = @sprintf "τ = %0.4f" tau)
    text!(ax0, .125, h0-3*dh, fontsize = 14, 
    text = @sprintf "Rate = %0.1f, CV = %0.2f, CV* = %0.2f" 1.0/(mu+tau) CV_fromExwaldModel(mu, lambda, tau) CVStar_fromExwaldModel(mu, lambda, tau))

    text!(ax0, .65, .92, fontsize = 16, text = "Stimulus Parameters:")
    h0 = .9
    dh = .02
    text!(ax0, .7, h0, fontsize = 16, text = @sprintf "Amplitude = %0.2f (%.4f x drift)" A A/v0)
    text!(ax0, .7, h0-dh, fontsize = 16, text = @sprintf "Frequency = %0.1fHz" F)    
    hidedecorations!(ax0)

    # ax1 shows stimulus, spike train and rate
    ax1 = Axis(Fig[1, NP+2], title = "Stimulus & spikes during one cycle")
    xlims!(ax1, 0., 1.0/F)
    ax1.xticks = vec([-1])
    ax1_width = 0.75*FigRadius
    ax1_height = ax1_width/(1.0+sqrt(5))
    period = 1.0/F
    t1 = collect(0.0:dt4glr:period)
    lines!(ax1, t1, [stimulus(t) for t in t1], color = :black, linewidth = 1.0)   # plot 1 cycle of stimulus
    display(Fig)  # to compute axis limits
    splot!(ax1, spt[minimum(findall(spt.>period)):maximum(findall(spt.<2.0*period))] .- period,
          ylims(ax1)[2]/4.0, 1.0, :navyblue)   

    # ax2 shows rate in every cycle except first and last (ignore edge effects in GLR)
    Nperiods = Int(min(floor(maximum(spt)/period), 128))
    ax2 = Axis(Fig[1, NP+3], title = @sprintf "Rate (%0.0f cycles)" Nperiods)
    xlims!(ax2, 0.0, 1.0/F)

    ns = Int(period/dt4glr)  # number of glr samples in period
    averageRate = zeros(ns+1)
    for i in 2:Nperiods
        averageRate = averageRate + glrate[((i-1)*ns).+(0:ns)]
        lines!(ax2, t1, glrate[((i-1)*ns).+(0:ns)], linewidth = 0.5)
    end
    lines!(ax2, t1, averageRate./Nperiods, linewidth = 4.0, color = :white)
    lines!(ax2, t1, averageRate./Nperiods, linewidth = 2.0, color = :black)

    insetPlotWide = 160.0
    insetPlotHigh = 160.0
    R = 0.7*FigRadius #  plot circle radius relative to width of parent axes
    spi = 1  # subplot index counter
    ax = []
    x0 = zeros(NP)
    y0 = zeros(NP)   
    xbig = -99.0   # for computing the x-axis limit, = 2x largest mean of fitted models in cycle
    fitted_param = zeros(3, NP)   # holds fitted Exwald parameters in columns
    for i in 1:NP

        phaseRadians = -phaseAngle[i] * pi / 180.0


        # intervals at specified phase
        I0 = intervalPhase(spt, phaseAngle[i], F, true)

        ax = (ax[:]..., Axis(Fig[1,i], xlabel = @sprintf "%.0f° " phaseAngle[i] ))
        x0[i] = round(FigRadius - R * cos(phaseRadians) - insetPlotHigh/2.0)       
        y0[i] = round(FigRadius - R * sin(phaseRadians) - insetPlotHigh/2.0)

        T = maximum(I0)
        t = collect(0.0:dt:T)

        # predicted Distributions
        v = v0 + stimulus(phaseAngle[i] / (360.0 * F)) # stimulus at phaseAngle[i]
        (mu_model, lambda_model) = Wald_parameters_from_FirstpassageTimeModel(v, s, barrier)
        tau_model = PoissonTau_from_ThresholdTrigger(v, s, trigger, dt)

        # X = Exwaldpdf(mu_model, lambda_model, tau_model, t)
        # W = pdf(InverseGaussian(mu_model, lambda_model), t)
        # P = exp.(-t ./ tau_model) ./ tau_model

        lw = 1.0
        spi = spi + 1
        H = hist!(I0, bins=128, normalization=:pdf)

        # fit Exwald Model
        (maxf, fitted_param[:,i], ret) = Fit_Exwald_to_ISI(I0, [mu_model, lambda_model, tau_model])

        thisbig = fitted_param[1,i] + fitted_param[3,i]   # mean = mu + tau
        if thisbig > xbig
            xbig = thisbig
        end

        lines!(ax[i], t,  
            Exwaldpdf(fitted_param[1,i], fitted_param[2,i], fitted_param[3,i], t), 
            color = :salmon1, linewidth = 2.0)
        
        # set axis limits and remove ticks
        # display(Fig)
        # xlims!(ax[i], 0.0, 0.2) 
        # ax[i].xticks = vec([-1])
        # ylims!(ax[i], 0.0, ymax)
        # ax[i].yticks = vec([-1])
        
        #text!()
          
    end # phase angles

 

    display(Fig)  

    xmax = -99.0
    ymax = -99.0
    for i in 1:NP
        xmax = max(xmax, xlims(ax[i])[2])
        ymax = max(ymax, ylims(ax[i])[2])
    end

    xbig = 3.0*round(100.0*xbig)/100.0
    # if xbig<.1
    #     xbig = 2.0*round(100.0*xbig)/100.0
    # end
    # if xbig < .01  # don't expect this to happen. 
    #     xbig = .01
    # end
    for i in 1:NP
        xlims!(ax[i], 0.0, xbig) #xmax)
        ax[i].xticks = vec([-1])
        ylims!(ax[i], 0.0, ymax)
        ax[i].yticks = vec([-1])
    end

    # show fitted parameters
    h0 = 0.8
    dh = .1
    for i = 1:NP 
        text!(ax[i], xbig/2.0, h0*ymax, text = @sprintf "μ = %.4f" fitted_param[1,i])
        text!(ax[i], xbig/2.0, (h0-dh)*ymax, text = @sprintf "λ = %.4f" fitted_param[2,i])
        text!(ax[i], xbig/2.0, (h0-2.0*dh)*ymax, text = @sprintf "τ = %.4f" fitted_param[3,i])
    end

    #@infiltrate
    # plots are complete
    scalebarx = xlims(ax[1])[2]*[5/8, 7/8]  # scalebar endpoints
    scalebarlen = round(diff(scalebarx)[]*1000.)
    lines!(ax[1], scalebarx, 0.2*ymax*[1.0, 1.0], color = :black, linewidth = 2)

    text!(ax[1], mean(scalebarx), .25*ymax, text = (@sprintf "%0.0fms" scalebarlen), align = (:center,:center))

    # plots are complete, now move them into position
    for i in 1:NP
        setAxisBox(ax[i], x0[i], y0[i], insetPlotWide, insetPlotHigh)
    end
    setAxisBox(ax0, 0.0, 0.0, 2.0*FigRadius, 2.0*FigRadius)
    setAxisBox(ax1, FigRadius - ax1_width/2.0, FigRadius + 0.1*ax1_height,
                    ax1_width, ax1_height)
    setAxisBox(ax2, FigRadius - ax1_width/2.0, FigRadius - 1.1*ax1_height,
                    ax1_width, ax1_height)

    display(Fig)

    save("Exwald_Neuron_PhaseISI.png", Fig)

   Fig

end


function show_Exwald_Neuron_sineresponse( Exwald_param::Tuple{Float64,Float64,Float64},
    Stim_param::Tuple{Float64,Float64}, Nperiods::Int = 64,
    sd::Float64 = -1.0, 
    dt::Float64 = -1.0)


    # extract parameters
    (mu, lambda, tau) = Exwald_param
    (A, F) = Stim_param

    # default GLR filter bandwidth 10% of period
    if sd < 0.0
        sd = 0.025/F
    end

    # default sampling interval smalller of .1 filter width or .1 tau
    if dt < 0.0
        dt = 0.1
        while dt > min(sd, tau)
            dt = 0.1*dt
        end
        dt = 1.0/Int(round(1.0/dt))   # fix numerical error in divide-by-10
    end


    (v0, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)   # Drift speed, noise s.d. & barrier height for Wald component
    trigger = TriggerThreshold_from_PoissonTau(v0, s, tau, dt)            # threshold for Poisson component using same noise

    # sinusoidal stimulus
    stimulus(t) = A * sin(2 * π * F * t)

    Period = 1.0/F

    # simulate Exwald neuron for 131 cycles (1st 2 & last 1 will be discarded)
    spt = Exwald_Neuron(Float64(Nperiods+3)*Period, (mu, lambda, tau), stimulus)

    # rate estimate
    #dt4glr = 0.01
    (tx, glrate) = GLR(spt, sd, dt);



    R0 = 1.0

    Fig = Figure(size = (1200, 600))

    # ax0 allows text to be placed anywhere on the figure
    ax1 = Axis(Fig[1,1])
    ax2 = Axis(Fig[2,1])


    period = 1.0/F
    t1 = collect(0.0:dt:period)
    lines!(ax1, t1, [stimulus(t) for t in t1], color = :black, linewidth = 1.0)   # plot 1 cycle of stimulus
    display(Fig)
    splot!(ax1, spt[minimum(findall(spt.>2.0*period)):maximum(findall(spt.<3.0*period))] .- 2.0*period,
          ylims(ax1)[2]/4.0, 1.0, :navyblue)   


    ns = Int(round(period/dt))  # number of glr samples in period
    averageRate = zeros(ns+1)

    for i in 2 .+ (1:Nperiods)
        averageRate = averageRate + glrate[((i-1)*ns).+(0:ns)]
      #  if i <= 130 # display maximum of 128 rate samples 
            lines!(ax2, t1, glrate[((i-1)*ns).+(0:ns)], linewidth = 0.5)
       # end
    end

    lines!(ax2, t1, averageRate./Nperiods, linewidth = 4.0, color = :white)
    lines!(ax2, t1, averageRate./Nperiods, linewidth = 2.0, color = :black)

    (minf, pest, ret) = Fit_Sinewave_to_Spiketrain(spt, F, sd, dt)

    lines!(ax2, t1, sinewave(pest,F,t1), color = :white, linewidth = 4.0)
    lines!(ax2, t1, sinewave(pest,F,t1), color = :red, linewidth = 2)
 
    xlims!(ax1, [0.0, period])
    xlims!(ax2, [0.0, period])   
    display(Fig)

   (minf, pest)

end


# test fit stationary Exwald distribution to spontaneous Exwald neuron model
# N = sample size
function test_fit_Exwald_neuron_stationary(N::Int64, mu::Float64, lambda::Float64, tau::Base.Float64)


    # spontaneous interspike intervals 
    ISI =  diff(vcat([0.0], Exwald_Neuron_Nspikes(N, (mu, lambda, tau), t->0.0)))

    (maxf, p, ret) = Fit_Exwald_to_ISI(ISI, [mu, lambda, tau],  [0.1, 0.1, 0.1])

    dt = 1.0e-3
    T = maximum(ISI)
    t = collect(dt:dt:T)
    histogram(ISI, normalize=:pdf)
    plot!(t, Exwaldpdf(p[1], p[2], p[3], t), linewidth=2)
    display(plot!(t, Exwaldpdf(mu, lambda, tau, t), linewidth=2))

    p

end

#= 
# Extract ISI distribution for Exwald model neuron at specified phases of sinusoidal stimulus
# fit Exwald models to ISI data
# Plot estimated Exwald parameters vs instantaneous model parameters at fitAngles
#   0 <= phase <= 360
# eg call  test_fit_Exwald_Neuron_phasedistribution(50000, (.013, .1, .01), (1.0, 2.0), collect(0.0:45.0:360.));
function test_fit_Exwald_Neuron_phasedistribution(N::Int64,
    Exwald_param::Tuple{Float64,Float64,Float64},
    Stim_param::Tuple{Float64,Float64},
    phaseAngle::Vector{Float64}, fitAngle::Vector{Float64}=phaseAngle,
    endAtclosestSpike::Bool = false,
    dt::Float64=DEFAULT_SIMULATION_DT)

    # extract parameters
    (mu, lambda, tau) = Exwald_param
    (A, F) = Stim_param
    (v0, s, barrier) = FirstPassageTime_parameters_from_Wald(mu, lambda)   # Drift speed, noise s.d. & barrier height for Wald component
    trigger = TriggerThreshold_from_PoissonTau(v0, s, tau, dt)            # threshold for Poisson component using same noise

    # sinusoidal stimulus
    stimulus(t) = A * sin(2 * π * F * t)
    #stimulus(t) = A * sign(sin(2 * π * F * t))    
    # function stimulus(t)
        
    #     if sin(2 * π * F * t)^2 > 0.5
    #         return A*sign(sin(2 * π * F * t))
    #     else
    #         return(0.0)
    #     end
    # end
    
    Nphases = length(phaseAngle)

    # layout plot window
    # top row for histograms, bottom row for parameter fits
    lyt = @layout [
        grid(1,Nphases){.25h}
        grid(3,1) 
    ]
    
    Npts = 128
    R0 = 1.0
    plt = plot(layout = lyt,
        size=(1200, 1200), bgcolor=:white, gridcolor=:white, showaxis=false)
    ytickfontcolor = :white
    xtickfontcolor = :white

#     @infiltrate


    # R = 0.35 #  plot circle radius relative to width of parent axes
    # spi = 1  # subplot index counter


    # Extract interval lengths at specified phases of stimulus

    y_inset_offset = 0.05
    x_inset_offset = 0.05
    inset_h = (1.0-2.0*y_inset_offset)/Nphases
    inset_w = 0.2

    # arrays to hold fitted parameters

    mu_hat = zeros(Nphases)
    lambda_hat = zeros(Nphases)
    tau_hat = zeros(Nphases)

    # timescale for model evaluation (time delay from last spike)
    Td = 5.0*(mu+tau)
    td = collect(0.0:dt:Td)


    # simulate Exwald neuron
    spt = Exwald_Neuron(N, (mu, lambda, tau), stimulus)

    #@infiltrate

    for i in 1:Nphases

       # phaseRadians = -phaseAngle[i] * pi / 180.0


        # intervals at ith phase angle
        ISI_i = intervalPhase_independent(spt, phaseAngle[i], F)

        # fit model
        (maxf, p, ret) = Fit_Exwald_to_ISI(ISI_i, [0.5, 0.5, 0.5])

        mu_hat[i]     = p[1]
        lambda_hat[i] = p[2]
        tau_hat[i]    = p[3]

        # drift parameter of physical model
        v = v0 + stimulus(phaseAngle[i] / (360.0 * F))   # drift speed is spontaneous + stimulus-driven

        # Exwald model parameters from physical model parameters
        (mu_model, lambda_model) = Wald_parameters_from_FirstpassageTimeModel(v, s, barrier)
        tau_model = PoissonTau_from_ThresholdTrigger(v, s, trigger, dt)


        
        # evaluate "true" Exwald model pdf and its Ex- and -Wald components
        Exwald_model   = Exwaldpdf(mu_model, lambda_model, tau_model, td)
        Wald_model     = pdf(InverseGaussian(mu_model, lambda_model), td)
        Poisson_model  = exp.(-td ./ tau_model) ./ tau_model

        # fitted model
        Exwald_fitted = Exwaldpdf(mu_hat[i], lambda_hat[i],  tau_hat[i], td)

        #@infiltrate

        lw = 2.0
#
        H = histogram!(ISI_i, bins=0:1.0e-3:Td,
            normalize=:pdf, subplot=i, 
            linewidth=0.1, framestyle=:box,
            xticks=[0.02], xtickfontcolor=xtickfontcolor, xtickdirection=:out,
            yticks=[250.0], ytickfontcolor=ytickfontcolor, ytickdirection=:out)
        plot!(td, Wald_model, color = :grey, subplot=i)
        plot!(td, Poisson_model, color = :grey, subplot=i)
        plot!(td, Exwald_model, subplot=i, linewidth=lw, color=:darkorange,
            xlims=(0.0, Td), ylims=(0.0, 120.0), legend = :false)
        plot!(td, Exwald_fitted, subplot=i, linewidth=lw, color=:crimson)   
        mytext =  @sprintf "%2.0f°" phaseAngle[i]
        annotate!(0.05, 60.0, 
            text(mytext, 20), subplot = i)     
       # annotate!(0.03, 80.0, text("Hello")      )

       #@infiltrate

    end # phase angles

    # caLculate mu, lambda and tau over stimulus cycle
    dθ = 1.0  # 5° steps
    θ = 0.0:dθ:360.0
    Ns = length(θ)
    mu_dynamic     = zeros(Ns)
    lambda_dynamic = zeros(Ns)
    tau_dynamic    = zeros(Ns)

#    @infiltrate
    for i in 1:Ns 
        v = v0 + stimulus(θ[i]/(360.0*F))  
        (mu_dynamic[i], lambda_dynamic[i]) = 
             Wald_parameters_from_FirstpassageTimeModel(v, s, barrier)
        tau_dynamic[i] = PoissonTau_from_ThresholdTrigger(v, s, trigger, dt)
    end


    #@infiltrate

    # plot modeland fitted  mu during stimulus
    ymin = minimum(mu_dynamic)
    ymax = maximum(mu_dynamic)
    yrange = ymax - ymin

    plot!(θ, mu_dynamic, 
        ylims=(0.005, .025), framestyle=:box, legend = false, color = :dodgerblue, 
        xtick = phaseAngle, linewidth = 4, 
        showaxis = true, subplot = Nphases + 1)
    plot!(θ, mu*ones(length(θ)), 
        linewidth = 1.5, color = :seagreen, linestyle = :dash, subplot = Nphases + 1)
 
   
    # plot model and fitted lambda
    plot!(θ, lambda_dynamic,  xtick = phaseAngle,
        ylims=(0.0, 0.2), framestyle=:box, legend = false,  lw = 4, color = :dodgerblue, 
        showaxis = true, subplot = Nphases + 2)


    # plot model and fitted tau
    ymin = minimum(tau_dynamic)
    ymax = maximum(tau_dynamic)
    yrange = ymax - ymin    
    plot!(θ, tau_dynamic,  xtick = phaseAngle,
        ylims=(-0.00, 0.04), legend = false,  linewidth = 4, color = :dodgerblue, 
        showaxis = true, framestyle=:box, subplot = Nphases + 3) 
    plot!(θ, tau*ones(length(θ)), 
        linewidth = 1.5, color = :seagreen, linestyle = :dash, subplot = Nphases + 3)   

    pcolor = :firebrick
    msize = 2
    msw = 0.1
    scatter!(phaseAngle, mu_hat, 
        subplot = Nphases + 1, color = pcolor, 
        ms = msize, markerstrokewidth = msw)  
    annotate!(45.0, .02, text("μ", 30, :dodgerblue), subplot = Nphases+1)
    scatter!(phaseAngle, lambda_hat, 
        subplot = Nphases + 2, color = pcolor, 
        ms = msize, markerstrokewidth = msw)  
    annotate!(45.0, .15, text("λ", 30, :dodgerblue), subplot = Nphases+2)
    scatter!(phaseAngle, tau_hat, 
        subplot = Nphases + 3, color = pcolor, 
        ms = msize, markerstrokewidth = msw)  
    annotate!(45.0, .025, text("τ", 30, :dodgerblue), subplot = Nphases+3)


    Nfit = length(fitAngle)
    mu_hatf = zeros(Nfit)
    lambda_hatf = zeros(Nfit)
    tau_hatf = zeros(Nfit)
    for rep = 1:3
        # simulate Exwald neuron
        spt = Exwald_Neuron(N, (mu, lambda, tau), stimulus)    
        
        for i in 1:Nfit
            # intervals at ith phase angle
            ISI_i = intervalPhase_independent(spt, fitAngle[i], F)

            # fit model
            (maxf, p, ret) = Fit_Exwald_to_ISI(ISI_i, collect(Exwald_param),  collect(Exwald_param))

            mu_hatf[i]     = p[1]
            lambda_hatf[i] = p[2]
            tau_hatf[i]    = p[3]
        end
        scatter!(fitAngle, mu_hatf, 
            subplot = Nphases + 1, color = pcolor, 
            ms = msize, markerstrokewidth = msw)
        scatter!(fitAngle, lambda_hatf, 
            subplot = Nphases + 2, color = pcolor, 
            ms = msize, markerstrokewidth = msw)
        scatter!(fitAngle, tau_hatf, 
            subplot = Nphases + 3, color = pcolor, 
            ms = msize, markerstrokewidth = msw)  

    end #rep

    display(plt)

    # png("nameThisFigure")

    #@infiltrate

    (mu_hat, lambda_hat, tau_hat, spt)

end
 =#